<!doctype html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Buffer Geometry</title>
</head>
<body>
<img src="../../game2/roguelikeSheet_extracted.png" id="source">
<div id="container"></div>
<script src="../../tr2/three.js"></script>
<script src="../index.js"></script>
<script>

    let canvas = document.createElement("canvas");
    canvas.setAttribute("width", 16);
    canvas.setAttribute("height", 32);
    let ctx = canvas.getContext("2d");

    function addMesh(sourceX, method, height) {
        ctx.clearRect(0, 0, 16, 32);
        ctx.drawImage(document.getElementById("source"), sourceX*16, 0, 16, 32, 0, 0, 16, 32);
        let im = ctx.getImageData(0, 0, 16, height || 16);

        let vm = new ProjectionVerticesModel();
        method(vm, im);
        //vm.addImageSymmetric(im, 12);
        let te = new ThreeExport();

        let mesh = new THREE.Mesh(
                te.saveGeometry(vm),
                new THREE.MeshPhongMaterial({
                    map: te.saveTexture(vm)
                })
        );
        return mesh;


    }


    scene = new THREE.Scene();
    camera = new THREE.OrthographicCamera( 0, 80, 80, 0, 1, 1000 );
    camera.position.z = 100;
    camera.position.x = 0;
    camera.position.y = 0;

    renderer = new THREE.WebGLRenderer({ alpha: true, preserveDrawingBuffer: true });
    renderer.setClearColor( 0x000000, 0.2 );
    renderer.setSize( 320, 320);

    document.body.appendChild( renderer.domElement );

    var ambient = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambient);

    let mesh = addMesh(0, function(vm, im) { vm.addImageSymmetric(im, 12) });
    //mesh.material.side = THREE.DoubleSide;
    mesh.position.set(20,20,10);
    scene.add(mesh);
    mesh.rotateX(-Math.PI/2);
    let mesh2 = addMesh(3, function(vm, im) { vm.addImageFlatX(2, 4, im) }, 32);
    //mesh.material.side = THREE.DoubleSide;
    mesh2.position.set(20,40,10);
    scene.add(mesh2);
    //mesh2.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,0,0));
    //mesh2.geometry.applyMatrix(new THREE.Matrix4().makeRotationZ(Math.PI/2));
    //mesh2.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(6+2,0,0));
    //mesh2.rotateZ(-Math.PI/2);
    //mesh2.rotateZ(Math.PI/2+0.2);


    //console.log(mesh.geometry.attributes.position.count / 3);



    function render() {
        renderer.render(scene, camera);
        //mesh.rotateZ(0.01);
        //mesh2.rotateZ(0.01);
        //mesh2.rotateZ(0.01);
        //mesh.rotateX(-0.01);
        //mesh2.rotateX(0.01);
        requestAnimationFrame(render);
    }
    render();
</script>

</body>
</html>